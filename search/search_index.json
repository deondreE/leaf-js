{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the leaf-js docs","text":"<p>Here in the docs you should find questions to any of the problems that you may face. And an understanding of how leaf does things under the hood.</p>"},{"location":"#how-does-leaf-work","title":"How does leaf work?","text":"<p>Leaf leverages WebGPU, a modern JavaScript API that provides low-level access to GPU rendering and compute capabilities, enabling a more native and efficient rendering experience.</p> <p>At its core, Leaf structures rendering around pipelines\u2014akin to conveyor belts in a factory. Each scene in Leaf is assigned its own rendering pipeline, which processes instructions and sends them to the GPU for execution. These instructions are stored in a command queue and dispatched efficiently to maximize performance.</p> <p>Every shape within a scene is rendered with minimal overhead, both computationally and in terms of API complexity. To keep things performant and intuitive, Leaf ensures that pipelines are generated per scene and only recompiled when necessary\u2014such as when a new shape is introduced that modifies the rendering state. This approach reduces unnecessary recomputations while maintaining flexibility.</p>"},{"location":"#leafjs-comparison","title":"Leafjs Comparison","text":"<p>There are many existing 3D rendering solutions for the web, with Three.js being one of the most widely used. However, Three.js comes with significant complexity, requiring developers to understand intricate rendering concepts. LeafJS aims to simplify this by abstracting rendering details, allowing developers to create visually impressive experiences without deep knowledge of the underlying GPU operations.</p> <p>WebGL was designed in an era when OpenGL was the dominant rendering API. However, modern web rendering has evolved beyond OpenGL-based solutions. Leaf takes advantage of WebGPU, which offers a more direct and efficient path to the GPU, significantly outperforming WebGL in both rendering speed and power efficiency.</p> <p>For even greater performance, Leaf supports integration with WebAssembly (WASM), enabling near-native execution speeds. Since all web-based frameworks are ultimately constrained by the virtual GPU access granted by Chrome and other browsers, Leaf\u2019s use of WebGPU ensures the best possible performance within these limits.</p> <p>Additionally, Leaf utilizes WGSL, a shader language designed specifically for WebGPU. WGSL offers significant performance improvements over GLSL, optimizing shader execution for web environments. This results in lower latency, better memory efficiency, and improved compatibility with modern GPU architectures.</p>"},{"location":"code-style/","title":"Code Style","text":"<p>TODO: prebuild script -- \"Take all class files, and put them into created dirs\".</p>"},{"location":"code-style/#ai-use-policy","title":"Ai use policy","text":"<p>Go to the docs first -&gt; Ai use is fine to illustrate prof of context. -&gt; NO USE OF AI.</p>"},{"location":"code-style/#code-style_1","title":"Code Style","text":"<p>CPP-&gt;Zig:  - Snake case unless it is a class. <code>typedef</code>, <code>struct</code>  - Classes are camel case.   - 2 space indendting.  - I hate documentation comments. Write a readme file if needed.  - Zig -&gt; private methods lowercase.</p> <p>Javascript-&gt;Typescript:  - There are spcicfic usagee for <code>interfaces</code>, use them sparilly and as needed otherwise use a <code>type</code>.  - Stick to unix standards EOF.  - Semicolon is required! Commas also are required.  - Singleline variable declaration when possible.  - var -&gt; restricted ask first.  - Complex types will be thrown out. Unless they are needed.  - Global types <code>types.d.ts</code> -- ask first, even with generation...</p> <p>General:  - Api changes require approval.  - No custom exetensions for returned files.  - Don't use school accounts.</p>"},{"location":"reference/","title":"Api Reference","text":""},{"location":"reference/#static-scenes","title":"Static Scenes","text":"<p>Scenes that are not modified at runtime will write to file at buildtime.</p> <p>Static scenes are built to .YAML. Depending on the parser.</p> <p>Everytime a scene is created the <code>checkStatic</code> method is run. Then the correct checks are applied.</p> <p>On a specific event there will be a valid handler depending on if it is a static context or a dynamic context.</p>"},{"location":"reference/#rendering","title":"Rendering","text":"<p>The end-user, can communicated with the renderer, but by default will not have access to the \"Renderer\".</p> <p><code>On render</code>: a private <code>staticTransform</code> and public <code>transform</code> method should be used to apply static mutation from a 3rd party file and <code>transform</code> modifies the models buffer and marks model as dynamic.</p> <p><code>On render</code>: a private <code>checkSource</code> reads the source file type, and should return the type of rendering context needed. If it is a web-native supported context, it will return <code>null</code>. If it is unsupported it will throw an <code>UnsupportedTypeError</code>.</p> <p><code>OnLeafLoad</code>: checks all enqueued scenes for compliant pipelineDescriptor. </p> <p><code>On initialization</code>: the type of renderer is just an enum, and a switch will be used to pick out \"context\".</p> <p><code>On intialization</code>: If there is no selector provided leaf will create a <code>default</code> canvas, and call <code>injectDOM</code> which would be identical to <code>document.querySelector</code>.</p> <p><code>On intialization</code>: The default canvas is a Leaf-Canvas which is specified as a web component allowing for all child scenes to read a default pipeline.</p>"},{"location":"reference/#event-system","title":"Event System","text":"<p>Required for MVP.</p> <p>Dynamic -&gt; Static: Are the models being directly modified?</p> <p>The event system will delegate events based on the rendering type <code>static</code> or <code>dynamic</code></p>"},{"location":"reference/#profiler","title":"Profiler","text":"<p>Model bounding profiler, collisions. Vertexcount, fps count.</p> <p>Lazy collection of every dataset required.</p> <p><code>on render</code>: context is rendered using console.trace().</p> <p><code>on error</code>: Translate the error so that they are not as scary.</p>"},{"location":"reference/#model","title":"Model","text":"<p>Navigation Meshes:</p> <ul> <li>Cube -&gt; Cube mesh default</li> <li>Capsule</li> <li>Plane</li> </ul>"},{"location":"reference/#file-formats","title":"File formats","text":"<p>Supported file formats MVP:</p> <p>3d:  - Fbx  - Obj  - Stl</p> <p>2d:  - GIF  - PNG, JPEG  - SVG  - Aesprite</p>"}]}